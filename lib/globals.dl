; Special thanks to buildyourownlisp.com for the inspiration from 'lispy'!

(def {math.pi}    3.14159_26535_89793_23846_26433_83279_50288_41971_69399_37510_58209_74944_59230_78164_06286_20899_86280_34825_34211_70679_82148_08651_32823_06647_09384)
(def {math.e}     2.71828_18284_59045_23536_02874_71352_66249_77572_47093_69995)
(def {math.phi}   1.61803_39887_49894_84820_45868_34365_63811_77203_09179_80576)
(def {math.gamma} 0.57721_56649_01532_86061)

(def {fun local-fun}
  (fn {a b} {def (head a) (fn (tail a) b)})
  (fn {a b} {set (head a) (fn (tail a) b)}))

(fun {cons a b}      {join (list a) b})

; Helpers
(fun {nil? a}   {eq a NIL})
(fun {t? a}     {eq a T})
(fun {zero? a}  {eq a 0})
(fun {neg? a}   {< a 0})
(fun {pos? a}   {< 0 a})
(fun {one? a}   {eq a 1})
(def {trunc}    truncate)

; Comparisons
(fun {>= a b}   {< b a})
(fun {<= a b}   {> b a})
(fun {not a}    {if a {NIL} {T}})
(def {== <> !=} eq neq neq)

; Logical operators
(fun {xor a b} {
  and {or a b} {not (and a b)}
})

; Currying
(fun {unpack f l}  {eval (cons f l)})
(fun {pack f}      {f &_})

(def {apply curry uncurry} unpack unpack pack)

; Reverse
(fun {reverse} {
  if (and {defined? {&1}} {qexpr? &1} {&1})
    {join (reverse (tail &1)) (head &1)}
})

; nth element 
(fun {fst l} {eval (head l)})
(fun {snd l} {eval (head (tail l))})
(fun {thd l} {eval (head (tail (tail l)))})

(fun {nth n l} {
  if (zero? n)
    {fst l}
    {nth (- n 1) (tail l)}
})

(fun {last l} {nth (- (len l) 1) l})

; Take N items
(fun {take n l} {
  if (not (zero? n))
    {join (head l) (take (- n 1) (tail l))}
})

; Drop N items
(fun {drop n l} {
  if (zero? n)
    {l}
    {drop (- n 1) (tail l)}
})

; Split at N
(fun {split n l} {list (take n l) (drop n l)})

(fun {elem x l} {
  if l
    {if (eq x (fst l)) {T} {elem x (tail l)}}
})

; create a private scope
(fun {let x} {((fn NIL x) ())})

; do a number of items and return value of the last one
(fun {do} {if &_ {last &_}})

(def {begin} do)
(def {block} do)

; helpers
(fun {flip f a b} {f b a})
(fun {ghost}      {eval &_})
(fun {comp f g x} {f (g x)}) ; Compose

; map
(fun {map f l} {
  if l
    {cons (f (fst l)) (map f (tail l))}
})

; filter
(fun {filter f l} {
  if l
    {join (if (f (fst l)) {head l} {NIL}) (filter f (tail l))}
})

; fold left
(fun {foldl f z l} {
  if l
    {foldl f (f z (fst l)) (tail l)}
    {z}
})

(fun {sum s}     {foldl + 0 s})
(fun {product p} {foldl * 1 p})

; Switch/Cond
(fun {cond} {
  if &_
    {if (fst (fst &_))
      {snd (fst &_)}
      {apply cond (tail &_)} }
    {error "Selection not found"}
})

;(def {switch} cond)

(fun {case x} {
  if &_
    {if (eq x (fst (fst &_)))
       {snd (fst &_)}
       {apply case (cons x (tail &_))}}
    {error "Case not found"}
})

; math functions
(fun {abs a} {
  if (num? a)
   {if (< a 0) {- a} {a}}
   {error "Cannot perform 'abs' on non-number"}
})

(fun {floor a} {
  <=> (cmp a (trunc a))
    {< (- (trunc a) 1)}
    {(trunc a)}
})

(fun {ceil a} {
  <=> (cmp a (trunc a))
    {> (+ (trunc a) 1)}
    {(trunc a)}
})

(fun {div a b} {
  if (and {num? a} {num? b})
    {trunc (/ a b)}
    {error "Cannot perform 'div' on non-numbers"}
})

(fun {mod a b} {
  if (and {num? a} {num? b})
    {- a (* b (floor (/ a b)))}
    {error "Cannot perform 'mod' on non-numbers"}
})

(fun {divmod a b} {
  if (and {num? a} {num? b})
    {cons (div a b) (list (mod a b))}
    {error "Cannot perform 'divmod' on non-numbers"}
})

(fun {fdiv a b} {
  if (and {num? a} {num? b})
    {to-fixed (/ a b) (if (and {defined? {&3}} {num? &3}) {&3} {10})}
    {error "Cannot perform 'fdiv' on non-numbers"}
})

(fun {odd? n} {
  if (num? n)
    {eq (mod n 2) 1}
    {error "Cannot perform 'odd?' on non-number"}
})

(fun {even? n} {
  if (num? n)
    {eq (mod n 2) 0}
    {error "Cannot perform 'even?' on non-number"}
})

(fun {pow a b} {
  if (zero? b)
   {1}
   { if (even? b)
     {* (pow a (/ b 2)) (pow a (/ b 2))}
     {* a (pow a (- b 1))}
   }
})

; Math helper functions
(fun {1+ n} {+ n 1})
(fun {1- n} {- n 1})
(fun {square n} {* n n})
(fun {cube n} {* n (square n)})
(fun {recip n} {/ 1 n})
